# CVE-2024-1086 nf_tables.ko functions
## Tests done on stripped binaries
### Conversation log 1
#### Round 1
**Input:**
``` 
explain in detail what this function does?
```
**Decompiled Code (HLIL):**
```
7aa0 |   int64_t nft_verdict_init(int64_t* arg1, int32_t* arg2, void* arg3)
7ac1 | void* gsbase
7ac1 | int64_t rax = *(gsbase + 0x28)
7ad1 | char rax_2
7ad1 | int64_t rsi_1
7ad1 | int16_t* r9_1
7ad1 | rax_2, rsi_1, r9_1 = nft_genmask_next(*arg1)
7af7 | void var_48
7af7 | int64_t var_40
7af7 | 
7af7 | if (nla_parse_nested_deprecated.constprop.0(&var_48, rsi_1, r9_1) s>= 0 && var_40 != 0)
7afe |     int32_t temp0_1 = _bswap(nla_get_be32(var_40))
7b00 |     *arg2 = temp0_1
7b00 |     
7b06 |     if (temp0_1 u> 0xfffffffd)
7b0f |         *(arg3 + 8) = 0x10
7b06 |     else
7b0b |         int64_t var_38
7b0b |         
7b0b |         if (temp0_1 u> 0xfffffffb)
7b58 |             int64_t var_30
7b58 |             void* rdi_6
7b58 |             
7b58 |             if (var_38 != 0)
7b6d |                 char rax_10
7b6d |                 rax_10, rdi_6 = IS_ERR(nft_chain_lookup(*arg1, arg1[1], var_38, rax_2))
7b6d |                 
7b74 |                 if (rax_10 == 0)
7b9f |                     label_7b9f:
7b9f |                     char rax_13
7b9f |                     void* rdi_9
7b9f |                     rax_13, rdi_9 = nft_is_base_chain(rdi_6)
7b9f |                     
7ba6 |                     if (rax_13 == 0)
7ba8 |                         char rax_14
7ba8 |                         void* rdi_10
7ba8 |                         rax_14, rdi_10 = nft_chain_is_bound(rdi_9)
7ba8 |                         
7bbd |                         if (rax_14 == 0 && ((*(arg3 + 0xc) & 1) == 0 || (*(rdi_10 + 0x54) & 4) == 0))  {\"GNU\"}  {\"Linux\"}
7bbf |                             *(rdi_10 + 0x50) += 1
7bc3 |                             *(arg2 + 8) = rdi_10
7b0f |                             *(arg3 + 8) = 0x10
7b74 |                 else
7b76 |                     PTR_ERR()
7b58 |             else if (var_30 != 0)
7b96 |                 char rax_12
7b96 |                 rax_12, rdi_6 = IS_ERR(nft_chain_lookup_byid(*arg1, arg1[1], var_30))
7b96 |                 
7b9d |                 if (rax_12 == 0)
7b9d |                     goto label_7b9f
7b9d |                 
7b76 |                 PTR_ERR()
7b0b |         else if (temp0_1 == 0xfffffffb || (temp0_1.b & 0xfe) == 0 || temp0_1.b == 3)
7b0f |             *(arg3 + 8) = 0x10
7b0f | 
7b28 | if (rax == *(gsbase + 0x28))
7b38 |     return __x86_return_thunk() __tailcall
7b38 | 
7bd6 | __stack_chk_fail()
7bd6 | noreturn
```
**Output:**
```
The nft_verdict_init function appears to be part of a network filtering framework, likely related to Netfilter in Linux. Here's a detailed breakdown of its operations:
Initialization: 
The function takes three arguments: arg1, arg2, and arg3.
It retrieves a value from a thread-local storage area (gsbase), possibly for stack protection.
Mask Generation:
Calls nft_genmask_next with *arg1 to generate a mask, storing results in rax_2, rsi_1, and r9_1.
Nested Parsing:
Uses nla_parse_nested_deprecated.constprop.0 to parse nested attributes. If successful and var_40 is non-zero, it proceeds.
Endian Conversion:
Converts a value from big-endian to host-endian using _bswap and stores it in *arg2.
Conditional Checks:
If temp0_1 is greater than 0xfffffffd, sets a specific value in arg3.
For values between 0xfffffffc and 0xfffffffd, it performs chain lookups using nft_chain_lookup or nft_chain_lookup_byid.
Chain Handling:
Checks if the chain is an error using IS_ERR.
If not, it verifies if the chain is a base chain and whether it is bound.
Updates specific fields in the chain and arg2 if conditions are met.
Error Handling:
Calls PTR_ERR() if errors are detected during chain lookups.
Stack Protection:
Verifies stack integrity and calls __stack_chk_fail() if a stack corruption is detected.
Overall, the function initializes a verdict structure, performs various checks and lookups on chains, and ensures stack protection.
```
#### Round 2
**Input:**
```
this function seems to be vulnerable to an exploit, suggest areas where this function might be vulnerable to be exploited
```
**Decompiled Code:**  
`same as above`  
**Output:**
```
Here are potential areas in the nft_verdict_init function that might be vulnerable to exploitation:
Input Validation:
The function relies on external inputs (arg1, arg2, arg3) without apparent validation. Ensure these inputs are sanitized to prevent unexpected behavior or injection attacks.
Nested Parsing:
The use of nla_parse_nested_deprecated.constprop.0 suggests parsing of nested attributes. If not handled correctly, malformed input could lead to buffer overflows or memory corruption.
Endian Conversion:
The conversion using _bswap assumes the input is correctly formatted. Malformed input could lead to incorrect processing or overflow conditions.
Chain Lookup and Error Handling:
The function performs chain lookups (nft_chain_lookup, nft_chain_lookup_byid) and checks for errors using IS_ERR. If these functions do not handle errors robustly, they could be exploited to cause incorrect behavior or memory corruption.
Conditional Logic:
The conditional checks on temp0_1 and subsequent operations could be manipulated if temp0_1 is not properly validated, leading to logic errors or unintended state changes.
Stack Protection:
Although there is a stack check (__stack_chk_fail), ensure that all stack operations are safe and that buffer sizes are respected to prevent stack-based buffer overflows.
Race Conditions:
If this function is called in a multi-threaded environment, ensure that shared resources are properly synchronized to prevent race conditions.
Review these areas carefully, considering the context and environment in which the function operates, to identify and mitigate potential vulnerabilities.
```
#### Round 3
**Input:**
```
there is a use-after-free vulnerability with this function, explain how that will occur
```
**Decompiled code:**  
`same as above`  
**Output:**
```
A use-after-free vulnerability in the nft_verdict_init function could occur if a memory region is freed and then accessed again without proper reallocation or validation. Here's how it might happen in this function:
Chain Lookup and Handling:
The function performs chain lookups using nft_chain_lookup and nft_chain_lookup_byid. If these functions return a pointer to a chain that has been freed elsewhere in the code, subsequent operations on this pointer could lead to use-after-free.
Conditional Logic and Pointer Dereferencing:
After the chain lookup, the function checks if the chain is a base chain and whether it is bound. If the chain was freed before these checks, accessing its properties (e.g., *(rdi_10 + 0x54)) would result in use-after-free.
Lack of Proper Error Handling:
If the error handling (IS_ERR and PTR_ERR) does not adequately verify the validity of the pointers returned by the lookup functions, it might proceed with operations on a freed memory region.
Improper Synchronization:
In a concurrent environment, if another thread frees the chain while this function is executing, it could lead to use-after-free when accessing the chain's properties.
To mitigate this vulnerability, ensure that: - The lookup functions return valid and currently allocated pointers. - Proper synchronization mechanisms are in place if the function operates in a multi-threaded context. - Comprehensive error handling is implemented to verify the validity of pointers before dereferencing.
```

#### Round 4
**Input**
```
specifically which parts in this function are susceptable to this attack, explain in detail how an attacker can carry out this exploit
```
**Decompiled Code:**  
`same as above`  
**Output:**
```
In the nft_verdict_init function, the potential for a use-after-free vulnerability primarily revolves around the handling of chain pointers returned by the lookup functions. Here's a detailed explanation of how an attacker might exploit this:
Chain Lookup Functions:
The function calls nft_chain_lookup and nft_chain_lookup_byid to obtain pointers to chain structures. These functions are expected to return valid pointers, but if they return a pointer to a chain that has been freed, subsequent operations on this pointer could lead to use-after-free.
Dereferencing Freed Pointers:
After obtaining a chain pointer, the function checks if it is a base chain and whether it is bound. These checks involve dereferencing the pointer (e.g., *(rdi_10 + 0x54)). If the pointer is to a freed memory region, this dereferencing can lead to undefined behavior or exploitation.
Conditional Logic:
The logic at addresses 0x7b9f to 0x7bbd involves multiple checks and operations on the chain pointer. If an attacker can manipulate the state such that a freed pointer is used here, they could potentially execute arbitrary code or cause a crash.
Exploitation Steps:
Trigger Free: An attacker might first trigger a condition where a chain is freed but the pointer is still accessible.
Manipulate State: By influencing the program's state, the attacker ensures that the freed pointer is returned by the lookup functions.
Execute Malicious Code: When the function dereferences the freed pointer, the attacker could exploit this to execute arbitrary code, potentially by overwriting function pointers or other critical data structures.
To prevent this vulnerability, ensure that: - The lookup functions return only valid, allocated pointers. - Implement checks to verify the validity of pointers before use. - Use proper synchronization to prevent concurrent modifications that could lead to use-after-free.
```

### Conversation log 2
#### Round 1
**Input:**
```
this function is know to be vulnerable to a use-after-free vulnerability. The nft_verdict_init() function allows positive values as drop error within the hook verdict, and hence the nf_hook_slow() function can cause a double free vulnerability. explain how this will work based on the decompiled HLIL code 
```
**Decompiled Code:**
```
7aa0 |   int64_t nft_verdict_init(int64_t* arg1, int32_t* arg2, void* arg3)
7ac1 | void* gsbase
7ac1 | int64_t rax = *(gsbase + 0x28)
7ad1 | char rax_2
7ad1 | int64_t rsi_1
7ad1 | int16_t* r9_1
7ad1 | rax_2, rsi_1, r9_1 = nft_genmask_next(*arg1)
7af7 | void var_48
7af7 | int64_t var_40
7af7 | 
7af7 | if (nla_parse_nested_deprecated.constprop.0(&var_48, rsi_1, r9_1) s>= 0 && var_40 != 0)
7afe |     int32_t temp0_1 = _bswap(nla_get_be32(var_40))
7b00 |     *arg2 = temp0_1
7b00 |     
7b06 |     if (temp0_1 u> 0xfffffffd)
7b0f |         *(arg3 + 8) = 0x10
7b06 |     else
7b0b |         int64_t var_38
7b0b |         
7b0b |         if (temp0_1 u> 0xfffffffb)
7b58 |             int64_t var_30
7b58 |             void* rdi_6
7b58 |             
7b58 |             if (var_38 != 0)
7b6d |                 char rax_10
7b6d |                 rax_10, rdi_6 = IS_ERR(nft_chain_lookup(*arg1, arg1[1], var_38, rax_2))
7b6d |                 
7b74 |                 if (rax_10 == 0)
7b9f |                     label_7b9f:
7b9f |                     char rax_13
7b9f |                     void* rdi_9
7b9f |                     rax_13, rdi_9 = nft_is_base_chain(rdi_6)
7b9f |                     
7ba6 |                     if (rax_13 == 0)
7ba8 |                         char rax_14
7ba8 |                         void* rdi_10
7ba8 |                         rax_14, rdi_10 = nft_chain_is_bound(rdi_9)
7ba8 |                         
7bbd |                         if (rax_14 == 0 && ((*(arg3 + 0xc) & 1) == 0 || (*(rdi_10 + 0x54) & 4) == 0))  {\"GNU\"}  {\"Linux\"}
7bbf |                             *(rdi_10 + 0x50) += 1
7bc3 |                             *(arg2 + 8) = rdi_10
7b0f |                             *(arg3 + 8) = 0x10
7b74 |                 else
7b76 |                     PTR_ERR()
7b58 |             else if (var_30 != 0)
7b96 |                 char rax_12
7b96 |                 rax_12, rdi_6 = IS_ERR(nft_chain_lookup_byid(*arg1, arg1[1], var_30))
7b96 |                 
7b9d |                 if (rax_12 == 0)
7b9d |                     goto label_7b9f
7b9d |                 
7b76 |                 PTR_ERR()
7b0b |         else if (temp0_1 == 0xfffffffb || (temp0_1.b & 0xfe) == 0 || temp0_1.b == 3)
7b0f |             *(arg3 + 8) = 0x10
7b0f | 
7b28 | if (rax == *(gsbase + 0x28))
7b38 |     return __x86_return_thunk() __tailcall
7b38 | 
7bd6 | __stack_chk_fail()
7bd6 | noreturn
```
**Output:**
```
The nft_verdict_init function processes a verdict value and sets up a hook verdict. Here's how the use-after-free vulnerability might occur:
Verdict Value Check: The function checks the temp0_1 value (derived from nla_get_be32(var_40)). If temp0_1 is greater than 0xfffffffd, it sets a specific value at *(arg3 + 8).
Chain Lookup: If temp0_1 is between 0xfffffffc and 0xfffffffd, the function performs a chain lookup using nft_chain_lookup or nft_chain_lookup_byid. If these lookups return an error (IS_ERR), it calls PTR_ERR().
Base Chain and Binding Check: If the chain lookup is successful, it checks if the chain is a base chain and if it is bound. If these checks pass, it increments a reference count at *(rdi_10 + 0x50) and sets *(arg2 + 8) to rdi_10.
Potential Double Free: If temp0_1 is a positive value that is incorrectly interpreted as a drop error, it could lead to a situation where resources are freed twice. This happens because the function might not correctly handle the reference count or chain state, leading to a double free when nf_hook_slow() processes the verdict.
The vulnerability arises from improper handling of verdict values and chain states, potentially leading to a double free when the hook verdict is processed.
```
#### Round 2
**Input:**
```
how can a attacker exploit this vulnerability
```
**Decompiled Code:**  
`same as above`  
**Output:**
```
An attacker can exploit the use-after-free vulnerability in nft_verdict_init by manipulating the verdict value to trigger incorrect resource management. Here's how it might be done:
Crafting Malicious Input: The attacker provides a crafted input that results in a positive temp0_1 value, which is interpreted as a drop error. This input should be designed to bypass the checks and reach the code paths that manipulate reference counts and chain states.
Triggering Double Free: By ensuring that the crafted input leads to a situation where resources are freed twice, the attacker can cause memory corruption. This is typically achieved by manipulating the reference count or chain state in such a way that the same memory is freed more than once.
Exploiting Memory Corruption: Once memory corruption occurs, the attacker can exploit it to execute arbitrary code. This might involve overwriting function pointers, altering control flow, or injecting malicious code into the freed memory region.
Gaining Control: By carefully controlling the memory layout and exploiting the double free, the attacker can potentially gain control over the execution flow of the program, leading to privilege escalation or arbitrary code execution.
The key to exploitation is crafting inputs that precisely manipulate the internal state of the function to trigger the vulnerability.
```